<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <title>Sudoku Game</title>
    <style>
      #sudoku-board {
        border-collapse: collapse;
        margin: 0 auto;
        border: 1.5px solid black;
      }
      #sudoku-board td {
        width: 50px;
        height: 50px;
        border: 1px solid #ccc;
        text-align: center;
        font-size: 24px;
        padding: 0;
      }
      #sudoku-board td.editable,
      #sudoku-board td:has(input.editable) {
        background-color: #f0f0f0;
        color: #333;
        cursor: pointer;
      }
      #sudoku-board tr:nth-of-type(3n) td {
        border-bottom: 1.5px solid black;
      }
      #sudoku-board tr td:nth-of-type(3n) {
        border-right: 1.5px solid black;
      }
      #sudoku-board td input {
        width: 100%;
        height: 100%;
        box-sizing: border-box;
        text-align: center;
        border: none;
        background: transparent;
        color: #333;
        font-size: 24px;
        outline: none;
      }
      #sudoku-board td input::-webkit-outer-spin-button,
      #sudoku-board td input::-webkit-inner-spin-button {
        -webkit-appearance: none;
        appearance: none;
        margin: 0;
      }
      #sudoku-board td input[type="number"] {
        -moz-appearance: textfield;
        appearance: none;
      }
    </style>
  </head>
  <body>
    <div style="display: flex; flex-direction: column; align-items: center; gap: 0.5rem; padding: 1rem">
      <div class="button-container">
        <button onclick="clearCells()">Clear</button>
        <button onclick="solve()">Solve</button>
        <button onclick="newGame()">New Game</button>
      </div>
      <table id="sudoku-board"></table>
    </div>

    <script>
      // Examples of Sudoku board
      const easyBoards = [
        [
          [5, 3, 0, 0, 7, 0, 0, 0, 0],
          [6, 0, 0, 1, 9, 5, 0, 0, 0],
          [0, 9, 8, 0, 0, 0, 0, 6, 0],
          [8, 0, 0, 0, 6, 0, 0, 0, 3],
          [4, 0, 0, 8, 0, 3, 0, 0, 1],
          [7, 0, 0, 0, 2, 0, 0, 0, 6],
          [0, 6, 0, 0, 0, 0, 2, 8, 0],
          [0, 0, 0, 4, 1, 9, 0, 0, 5],
          [0, 0, 0, 0, 8, 0, 0, 7, 9],
        ],
        [
          [0, 0, 4, 5, 9, 0, 8, 0, 1],
          [9, 5, 0, 1, 0, 7, 4, 0, 0],
          [7, 1, 8, 0, 4, 3, 9, 0, 0],
          [0, 6, 2, 4, 0, 9, 0, 7, 0],
          [8, 0, 0, 7, 0, 6, 0, 0, 9],
          [4, 9, 0, 0, 1, 2, 8, 6, 0],
          [2, 0, 9, 0, 7, 5, 0, 1, 0],
          [0, 0, 9, 3, 0, 0, 2, 0, 0],
          [3, 7, 6, 8, 0, 5, 0, 0, 0],
        ],
        [
          [9, 0, 0, 6, 1, 0, 0, 3, 8],
          [8, 0, 6, 0, 0, 0, 1, 2, 0],
          [0, 0, 1, 0, 8, 0, 0, 0, 5],
          [5, 0, 0, 0, 9, 0, 6, 0, 4],
          [0, 6, 0, 8, 0, 1, 2, 0, 3],
          [0, 1, 0, 0, 6, 0, 0, 0, 0],
          [0, 0, 2, 0, 0, 0, 5, 7, 0],
          [3, 7, 0, 0, 5, 0, 0, 9, 0],
          [6, 0, 5, 9, 0, 7, 0, 0, 1],
        ],
        [
          [5, 0, 0, 0, 8, 0, 0, 1, 9],
          [1, 0, 7, 0, 0, 0, 2, 0, 0],
          [0, 0, 0, 3, 0, 7, 0, 8, 0],
          [3, 0, 0, 0, 7, 0, 0, 2, 8],
          [0, 9, 2, 0, 0, 0, 6, 0, 0],
          [0, 7, 4, 0, 0, 0, 0, 0, 5],
          [0, 2, 0, 0, 0, 0, 0, 7, 4],
          [0, 5, 0, 0, 0, 4, 0, 3, 0],
          [0, 0, 0, 0, 0, 2, 1, 9, 0],
        ],
      ];

      let initialBoard = [];

      function generateSudokuBoard(board) {
        initialBoard = board;
        const table = document.getElementById("sudoku-board");

        for (let i = 0; i < 9; i++) {
          const row = document.createElement("tr");

          for (let j = 0; j < 9; j++) {
            const cell = document.createElement("td");

            if (board[i][j] != 0) {
              cell.textContent = board[i][j];
            } else {
              const input = document.createElement("input");
              input.id = `${i},${j}`;
              input.type = "number";
              input.min = 1;
              input.max = 9;
              input.readOnly = true;
              input.classList.add("editable");
              cell.classList.add("editable");

              input.addEventListener("click", function () {
                this.readOnly = !this.readOnly;
              });

              cell.appendChild(input);
            }

            row.appendChild(cell);
          }

          table.appendChild(row);
        }
      }

      // Display the initial Sudoku board
      generateSudokuBoard(easyBoards[0]);

      function clearCells() {
        var table = document.getElementById("sudoku-board");

        for (var i = 0; i < 9; i++) {
          for (var j = 0; j < 9; j++) {
            var cell = table.rows[i].cells[j];

            // Check if the cell has a child element of type number input
            var numberInput = cell.querySelector('input[type="number"]');
            if (numberInput) {
              numberInput.value = "";
            }
          }
        }
      }

      function solve() {
        // We will store the domains of all the cells in a matrix
        // entry (k, l) signifies whether number l is in the domain of variable k
        // cell (i, j) in the sudoku board is represented by variable k = i * 9 + j
        var domains = Array(81)
          .fill(0)
          .map(() => {
            return Array(9).fill(1);
          });
        // we will flip (k, l) from 1 to 0 if the number l cannot be in the domain of variable k

        let fixed = []; // for storing indices of constraint variables in domain matrix corresponding to a fixed cell
        // matrix for storing the solution, initially set to zeros
        let solution = Array(9)
          .fill(0)
          .map(() => {
            return Array(9).fill(0);
          });

        // first, we will update the domain of fixed cells and the solution matrix
        for (let i = 0; i < 9; i++) {
          for (let j = 0; j < 9; j++) {
            const value = initialBoard[i][j];
            if (value != 0) {
              //console.log(`at ${i}, ${j}`);
              domains[i * 9 + j] = domains[i * 9 + j].map((_, index) => (index + 1 == value ? 1 : 0));
              //console.log(domains[i * 9 + j]);
              fixed.push(i * 9 + j); // adding its index
              solution[i][j] = value; // storing the value
            }
          }
        }

        // next, we will simulate AC-3 algorithm to satisfy constraints

        // modelling Sudoku with a constraints graph would include three types of arcs
        // (1) pairwise diferent values in a single row
        // (2) pairwise diferent values in a single column
        // (3) pairwise diferent values in a single 3x3 block

        // here, we will not implement the algorithm fully, which would involve a queue
        // to simplify, we will check the arc consistency of all arcs (i.e. constraints) every time a value is fixed

        // queue for storing variables whose arcs need to be checked
        let toUpdate = [...fixed];

        while (fixed.length < 81) {
          // take the first element that has singlton domain and check arc consistency
          if (toUpdate.length > 0) cell = toUpdate.shift();
          // since cell = i * 9 + j, i is the result of integer division with 9 and j i the remainder
          const j = cell % 9;
          const i = Math.floor(cell / 9);
          console.log(i, j);
          const value = solution[i][j];

          rowConsistency(value, i, j);
          columnConsistency(value, i, j);
          boxConsistency(value, i, j);
          //console.log(domains);

          // check if there are variables whose domains are reduced to a single element
          for (let p = 0; p < 81; p++) {
            if (fixed.includes(p)) continue; // the corresponding cell is already solved

            // checking there is a single one in a row, meaning domain is a singleton and the variable is solved
            if (
              domains[p].reduce((sum, elt) => {
                return sum + elt;
              }, 0) == 1
            ) {
              toUpdate.push(p);
              fixed.push(p);

              // to store the number that is left in the domain of the variable,
              // we take the index of the single element 1 that is left in this row of matrix "domains"
              // we increment by one since entry j a row of "domains" matrix corresponds to the value j + 1
              solution[Math.floor(p / 9)][p % 9] = domains[p].indexOf(1) + 1;
            }
          }
        }

        //displaying the solution
        var table = document.getElementById("sudoku-board");

        for (var i = 0; i < 9; i++) {
          for (var j = 0; j < 9; j++) {
            if (initialBoard[i][j] == 0) {
              var cell = table.rows[i].cells[j];
              cell.textContent = solution[i][j];
              cell.style.color = "green";
            }
          }
        }

        // checking same row -> fixed i
        function rowConsistency(value, i, j) {
          // looping over (i, 0), (i, 1), (i, 2), ..., (i, 8)
          for (let p = 0; p < 9; p++) {
            // setting to 0 for other cells in the same row meaning it is removed from the domain of that variable
            if (p != j) domains[i * 9 + p][value - 1] = 0;
          }
        }

        function columnConsistency(value, i, j) {
          // looping over (0, j), (1, j), ..., (8, j)
          for (let p = 0; p < 9; p++) {
            if (p != i) domains[p * 9 + j][value - 1] = 0;
          }
        }

        function boxConsistency(value, i, j) {
          // looping over (boxI, boxJ), ..., (boxI, boxJ + 2), ..., (boxI + 2, boxJ + 2)
          const boxI = Math.floor(i / 3) * 3;
          const boxJ = Math.floor(j / 3) * 3;
          for (p = boxI; p < boxI + 3; p++) {
            for (let q = boxJ; q < boxJ + 3; q++) {
              if (p != i || q != j) domains[p * 9 + q][value - 1] = 0;
            }
          }
        }
      }

      function newGame() {
        const board = easyBoards[Math.floor(Math.random() * easyBoards.length)];
        var table = document.getElementById("sudoku-board");
        table.innerHTML = "";
        generateSudokuBoard(board);
      }
    </script>
  </body>
</html>
